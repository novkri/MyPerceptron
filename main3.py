import numpy as np
xAll = np.array(([809], [416], [293], [341], [281], [859], [823], [242], [624], [398],
                 [511], [570], [476], [608], [256], [626], [898], [908], [638], [463],
                 [88], [361], [850], [454], [921], [370], [529], [610], [44], [182],
                 [512], [192], [463], [863], [402], [337], [835], [56], [704], [908],
                 [532], [885], [902], [483], [313], [879], [711], [591], [884], [963],
                 [957], [603], [929], [377], [922], [89], [790], [384], [998], [241],
                 [736], [83], [873], [490], [985], [963], [130], [538], [319], [882],
                 [658], [269], [132], [878], [434], [449], [107], [934], [380], [513],
                 [679], [59], [174], [61], [366], [439], [356], [39], [164], [654],
                 [631], [305], [351], [270], [364], [719], [577], [118], [201], [19],
                 [685], [886], [505], [115], [654], [739], [79], [323], [662], [56],
                 [190], [775], [889], [898], [301], [751], [590], [626], [870], [176],
                 [57], [245], [91], [75], [581], [27], [375], [758], [352], [447],
                 [305], [513], [751], [314], [378], [37], [622], [207], [827], [148],
                 [482], [254], [650], [291], [469], [864], [289], [678], [816], [889],
                 [397], [13], [961], [744], [535], [437], [581], [934], [331], [277],
                 [708], [281], [78], [901], [778], [67], [168], [13], [324],
                 [584], [354], [193], [519], [344], [254], [745], [873], [484], [414],
                 [529], [140], [248], [144], [309], [628], [960], [296], [913], [139],
                 [360], [331], [853], [780], [879], [265], [940], [531], [726], [654],

                 [891], [844], [739], [587], [269], [281], [741], [44], [798], [409],
                 [232], [50], [440], [892], [129], [503], [666], [692], [657], [415],
                 [730], [836], [422], [79], [353], [75], [927], [964], [96], [811],
                 [181], [208], [36], [520], [471], [353], [174], [983], [969], [346],
                 [399], [829], [432], [772], [262], [178], [896], [866], [664], [976],
                 [514], [155], [359], [444], [508], [515], [858], [832], [320], [406],
                 [365], [34], [490], [646], [228], [881], [986], [312], [242], [696],
                 [203], [69], [743], [455], [394], [281], [604], [307], [960], [953],
                 [747], [925], [407], [206], [851], [264], [22], [779], [993], [695],
                 [322], [125], [323], [958], [949], [649], [406], [296], [179], [492]), dtype=float)

y = np.array(([728.1], [374.4], [263.7], [306.9], [252.9], [773.1], [740.7], [217.8], [561.6], [358.2],
              [459.9], [513.0], [428.4], [547.2], [230.4], [563.4], [808.2], [817.2], [574.2], [416.7],
              [79.2], [324.9], [765.0], [408.6], [828.9], [333], [476.1], [549], [39.6], [163.8],
              [460.8], [172.8], [416.7], [776.7], [361.8], [303.3], [751.5], [50.4], [633.6], [817.2],
              [478.8], [796.5], [811.8], [434.7], [281.7], [791.1], [639.9], [531.9], [795.6], [866.7],
              [861.3], [542.7], [836.1], [339.3], [829.8], [80.1], [711.0], [345.6], [898.2], [216.9],
              [662.4], [74.4], [785.7], [441.0], [886.5], [866.7], [117.0], [484.2], [287.1], [793.8],
              [592.2], [242.1], [118.8], [790.2], [390.6], [404.1], [96.3], [840.6], [342.0], [461.7],
              [611.1], [53.1], [156.6], [54.9], [329.4], [395.1], [320.4], [35.1], [147.6], [588.6],
              [567.9], [274.5], [315.9], [243.0], [327.6], [647.1], [519.3], [106.2], [180.9], [17.1],
              [616.5], [797.4], [454.5], [103.5], [588.6], [665.1], [71.1], [290.7], [595.8], [50.4],
              [171.0], [697.5], [800.1], [808.2], [270.9], [675.9], [531.0], [563.4], [783.0], [158.4],
              [51.3], [220.5], [81.9], [67.5], [522.9], [24.3], [337.5], [682.2], [316.8], [402.3],
              [274.5], [461.7], [675.9], [282.6], [340.2], [33.3], [559.8], [186.3], [744.3], [133.2],
              [433.8], [228.6], [585.0], [261.9], [422.1], [777.6], [260.1], [610.2], [734.4], [800.1],
              [357.3], [11.7], [864.9], [669.6], [481.5], [393.3], [522.9], [840.6], [297.9], [637.2],
              [252.9], [70.2], [810.9], [700.2], [60.3], [151.2], [11.7], [291.6], [525.6], [318.6],
              [173.7], [467.1], [309.6], [228.6], [670.5], [785.7], [435.6], [372.6], [476.1], [126.0],
              [223.2], [129.6], [278.1], [565.2], [864.0], [266.4], [821.7], [125.1], [324.0], [297.9],
              [767.7], [702.0], [791.1], [238.5], [846.0], [477.9], [653.4], [588.6], [801.9]), dtype=float)

xAll = xAll / 1000
# np.amax(xAll, axis=0)
y = y / 1000

X = np.split(xAll, [199])[0]
xPredicted = np.split(xAll, [199])[1]



class neural_network(object):
    def __init__(self):
        self.inputSize = 1
        self.outputSize = 1
        self.hiddenSize = 3

        self.W1 = np.random.randn(self.inputSize, self.hiddenSize) / 100
        self.W2 = np.random.randn(self.hiddenSize, self.outputSize) / 100
        print(self.W1)


    def forward(self, X):
        # forward propagation
        self.z = np.dot(X, self.W1)  # умножение X (input) и первого набора весов 3x1
        self.z2 = self.sigmoid(self.z)  # activation function
        self.z3 = np.dot(self.z2, self.W2)  # перемножение скрытого слоя (z2) и второго набора весов 3x1
        o = self.sigmoid(self.z3)  # activation function
        return o

    def sigmoid(self, s):
        return 1 / (1 + np.exp(-s))

    def sigmoidPrime(self, s):
        return s * (1 - s)

    def backward(self, X, y, o):
        # backward propagate
        self.o_error = y - o  # ошибка на выходе
        self.o_delta = self.o_error * self.sigmoidPrime(o)  # применение производной от сигмоиды на ошибку

        self.z2_error = self.o_delta.dot(self.W2.T)
        self.z2_delta = self.z2_error * self.sigmoidPrime(self.z2)

        self.W1 += 0.1 * np.dot(X.T, self.z2_delta)  # подстройка весов (input --> hidden)
        self.W2 += 0.1 * np.dot(self.z2.T, self.o_delta)  # подстройка весов (hidden --> output)

    def train(self, X, y):
        o = self.forward(X)
        self.backward(X, y, o)

    def predict(self):
        print("Predicted: ")
        # print("Input: \n" + str(xPredicted))
        # print("Output: \n" + str(self.forward(xPredicted) * 100))
        print("Loss: \n" + str(np.mean(np.square(xPredicted - self.forward(xPredicted))) ))
        # mean sum squared loss

NN = neural_network()

for i in range(10000):
    print("# " + str(i) + "\n")
    # print ("Input: \n" + str(X))
    # print("Actual Output: \n" + str(y * 100))
    # print("Predicted Output: \n" + str(NN.forward(X) * 100))
    # print("Loss: \n" + str(np.mean(np.square(y - NN.forward(X))) ))
    print("\n")
    NN.train(X, y)
    # сортировка ? :
    # rng_state = np.random.get_state()
    # np.random.shuffle(X)
    # np.random.set_state(rng_state)
    # np.random.shuffle(y)
print("Loss: \n" + str(np.mean(np.square(y - NN.forward(X))) ))
NN.predict()
